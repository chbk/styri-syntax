.syntax--source:not(.syntax--css):not(.syntax--gfm):not(.syntax--json):not(.syntax--regexp) {
  color: @syntax-color-src-variable;

  // comments
  .syntax--comment, .syntax--docstring {
    color: @syntax-color-comment;
    font-style: italic;

    * {
      color: @syntax-color-comment !important;
    }
  }

  // regexp
  .syntax--regexp {
    color: @syntax-color-src-regexp;

    * {
      color: @syntax-color-src-regexp !important;
    }
  }

  // strings
  .syntax--quoted:not(.syntax--docstring) {
    color: @syntax-color-src-string;

    // exclude embedded code
    >*:not(.syntax--embedded) {
      color: @syntax-color-src-string;

      * {
        color: @syntax-color-src-string;
      }
    }

    // interpolated variables
    .syntax--variable {
      color: @syntax-color-src-variable;

      &.syntax--punctuation {
        color: @syntax-color-punctuation;
      }
    }
  }

  // [ruby] :symbol
  .syntax--symbol.syntax--ruby {
    color: @syntax-color-src-symbol;
  }

  // {} () ;
  .syntax--punctuation:not(.syntax--string):not(.syntax--comment) {
    color: @syntax-color-punctuation;

    // [ruby] :''
    &.syntax--symbol.syntax--ruby {
      color: @syntax-color-src-symbol;
    }

    // [ruby] :
    &.syntax--constant.syntax--ruby:not(.syntax--hashkey) {
        color: @syntax-color-src-symbol;
    }
  }

  // [js] , . ()
  .syntax--delimiter, .syntax--brace {
    color: @syntax-color-punctuation;
  }

  // try catch return do
  .syntax--keyword {
    color: @syntax-color-src-keyword;

    // && = <
    &.syntax--operator {
      color: @syntax-color-src-operator;

      // [c] sizeof
      &.syntax--sizeof {
        color: @syntax-color-src-keyword;
      }

      // [c++] const_cast dynamic_cast and not alignof
      &.syntax--cpp {
        color: @syntax-color-src-keyword;
      }

      // [js] new delete typeof instanceof in of void
      &.syntax--new, &.syntax--delete,
      &.syntax--typeof, &.syntax--instanceof,
      &.syntax--in, &.syntax--of, &.syntax--void {
        color: @syntax-color-src-keyword;
      }

      // [perl] eq ne lt gt le ge cmp
      &.syntax--comparison.syntax--stringwise {
        color: @syntax-color-src-keyword;
      }

      // [python] and or not is in
      // [perl] and or not xor as, not && ||, not //
      &.syntax--logical.syntax--python,
      &.syntax--logical.syntax--perl:not(.syntax--c-style):not(.syntax--defined-or) {
        color: @syntax-color-src-keyword;
      }
    }

    // ? :
    &.syntax--ternary {
      color: @syntax-color-src-operator;
    }
  }

  // this super
  .syntax--language {
    color: @syntax-color-src-keyword;

    // [python] param in function(param), not self
    &.syntax--parameter:not(.syntax--special) {
      color: @syntax-color-src-variable;
    }

    // true false undefined null
    &.syntax--constant {
      color: @syntax-color-src-constant;
    }

    // *
    &.syntax--wildcard {
      color: @syntax-color-src-operator;
    }
  }

  // let def const
  .syntax--storage {
    color: @syntax-color-src-keyword;

    // [java] String, not int, not ->
    &.syntax--type.syntax--java:not(.syntax--primitive):not(.syntax--arrow) {
      color: @syntax-color-src-variable;

      // [java] ?
      &.syntax--wildcard {
        color: @syntax-color-src-operator;
      }
    }

    // [java] path in import path
    &.syntax--modifier.syntax--java.syntax--import,
    &.syntax--modifier.syntax--java.syntax--package {
      color: @syntax-color-src-variable;
    }

    // [java, js, coffee] => ->
    &.syntax--type.syntax--arrow,
    &.syntax--function.syntax--coffee {
      color: @syntax-color-src-operator;
    }
  }

  // 2 0x7 10e-3
  .syntax--constant.syntax--numeric {
    color: @syntax-color-src-numeric;

    // decimal periods
    .syntax--period {
      color: @syntax-color-src-numeric;
    }

    // [python] 0x 0b 0o
    .syntax--type {
      color: @syntax-color-src-numeric;
    }
  }

  // invalid
  .syntax--invalid {
    color: @syntax-color-src-invalid;
  }
}
